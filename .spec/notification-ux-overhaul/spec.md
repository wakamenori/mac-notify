# 通知UX拡張 仕様書

## 要約

- **採用案**: Gemini分析は通知受信時に完了させ、メニュー表示時の再分析は行わない。トレイメニューは「アプリ別親カテゴリ」を起点に、各通知を`緊急度ラベル + 要約`で表示する。
- **スコープ**: `src-tauri/src/main.rs` の通知分析・メニュー生成・クリックイベント・クリア操作を拡張する。
- **主要リスク**: macOSネイティブメニューでは文字色の直接変更が難しく、色分け表現に代替案が必要。

## 目的 / 背景

### 背景

現状はトレイに件数しか出ず、どのアプリのどの通知を先に処理すべきかを判断しにくい。

### 目標

- トレイを開いた時点で、アプリ単位で通知を把握できる。
- 各通知を「緊急度」と「要約」で一目判別できる。
- 既読扱いにするためのクリア操作をトレイから直接実行できる。

### 対象外

- 通知送信元アプリの深いディープリンク
- 永続ストレージ導入（再起動後の状態保持）

### スコープ

- 対象:
  - 通知分析結果の保持（受信時1回）
  - アプリ別サブメニュー表示
  - 通知クリック時の詳細表示
  - クリア機能（通知単位/アプリ単位/全体）
- 対象外:
  - Notification DB読み取り方式変更
  - Focus判定方式変更

## 現状と制約

### 事実

- 現在は `urgent/normal` の2値判定のみ（`src-tauri/src/main.rs`）。
- トレイは `通知を要約 / 収集済み: N件 / 終了` の固定構成（`src-tauri/src/main.rs`）。
- Tauri 1.8 は `SystemTrayHandle::set_menu` による動的メニュー再構築が可能。

### 制約

- Geminiは失敗し得るためフォールバックが必須。
- Tauri 1.8 のメニュー更新APIは `SetTitle/SetEnabled/SetSelected/SetNativeImage` が中心で、文字色指定APIはない（依存ソース確認）。
- メニュー過長を防ぐため、アプリごとの表示件数上限が必要。

## 採用案

### 決定内容

- Gemini分析は通知受信時に1回だけ実行し、`AnalyzedNotification` としてメモリ保持する。
- 緊急度は4段階を維持する。
  - `R4=critical`
  - `R3=high`
  - `R2=medium`
  - `R1=low`
- トレイ構造はアプリ別親カテゴリにする。
  - 親: `<アプリ名> (件数)`
  - 子: `<緊急度ラベル> <要約>` の通知行（クリック可能）
  - 子末尾: `このアプリをクリア`
- ルートメニュー末尾に `全通知をクリア`、`通知を要約`、`終了` を置く。
- 通知行クリックで Gemini分析詳細ダイアログを表示する。
- クリアは「表示上の削除」として `collected` から除去する（DB削除はしない）。

### ラベル色分けの実装方式

- 方式A: 絵文字で色ラベルを表現（`🔴R4`, `🟠R3`, `🟡R2`, `🟢R1`）
  - メリット: 実装が最小、Tauri標準APIで確実に動く。
  - デメリット: 見た目がOSフォント依存。
  - 導入の意味: 短期で色分けUXを成立できる。
- 方式B: テキスト先頭に色付きUnicode記号（`●`など）
  - メリット: 表記がシンプル。
  - デメリット: 色が出ない環境がある。
  - 導入の意味: ミニマルUI寄り。
- 方式C: 各メニュー項目へ NativeImage を付与
  - メリット: 視認性が高く、色表現が安定しやすい。
  - デメリット: 画像アセット管理と実装工数が増える。
  - 導入の意味: 見た目品質を優先する中期対応。

### 合意の粒度

**このSpecで今決めること**:

- メニュー情報設計（アプリ別親カテゴリ）
- 通知行フォーマット（緊急度ラベル + 要約）
- クリア操作の責務境界（メモリ削除のみ）

**後回しにすること**:

- 1アプリ内の表示上限件数（初期値）
- 要約文字数の省略ルール
- クリック時に元アプリを前面化するか

**判断の理由**:

不可逆性が高いのはメニュー階層とイベントID設計であり、文言や件数上限は後で安全に調整できるため。

### 変更の要点

- 契約/API:
  - Gemini応答を構造化JSONとして解析し、通知行表示に必要な項目を固定。
- データ/状態:
  - `AnalyzedNotification` を導入し、`app_name`/`urgency_level`/`summary_line`/`reason` を保持。
  - `clear_notification(id)`、`clear_app(bundle_id)`、`clear_all()` を追加。
- 振る舞い:
  - `update_tray_count` を `update_tray_menu_by_app` に置換。
  - メニュークリックイベントを `open:<id>`, `clear:<id>`, `clear_app:<bundle_id>`, `clear_all` で処理。

### 前提

- `GOOGLE_API_KEY` 未設定時はローカル規則で分析結果を生成して表示を維持する。

### 保留事項

- 色分け方式を A/B/C のどれで固定するか。

## 根拠・トレードオフ

### なぜこの案か

- アプリ別階層は、通知元を起点に処理する日常運用と一致する。
- 集計を省くことで、メニュー開封後の意思決定を「どの通知を開くか」に集中できる。

### リスクと緩和策

- リスク: 通知数増加でサブメニューが長くなる。
  - 緩和策: アプリごと上限表示 + `他N件` 行を追加。
- リスク: クリア誤操作。
  - 緩和策: `全通知をクリア` のみ確認ダイアログを出す。

### 影響

- 性能: 受信時分析のみのため、メニュー表示は軽い。
- 互換性: 既存機能との破壊的変更はない。
- 運用: クリア操作により、運用中のノイズ管理がしやすくなる。
- コスト（開発/保守）: 中程度（メニューID管理と削除ロジック追加）。

## 却下案

- 案A: メニュー開封時に毎回Geminiで再分析。
  - 却下理由: レイテンシとAPIコストが増え、UXが不安定。
- 案B: 集計表示をメインに残す。
  - 却下理由: ユーザー要求が「通知個別の判断重視」に寄っている。

## 品質保証計画

### 受け入れ基準

- トレイメニューがアプリ別親カテゴリで表示される。
- 各通知行に緊急度ラベルと要約が表示される。
- 通知クリックで該当通知の詳細が開く。
- 通知単位・アプリ単位・全体クリアが機能する。
- Gemini失敗時でも通知行は生成される。

### テスト戦略

- ユニット:
  - Geminiレスポンスパース（正常/壊れたJSON）
  - アプリ別グルーピング
  - クリア処理（単体/アプリ/全体）
- 統合:
  - 疑似通知投入時のメニュー項目生成とイベントID整合
- E2E:
  - Focus ON/OFFで収集、表示、クリック、クリアの一連動作確認

### 観測可能性

- ログ:
  - 分析成功/失敗、メニュー再構築件数、クリア操作イベント
- メトリクス:
  - 分析成功率、クリア実行回数
- アラート:
  - Gemini連続失敗時のwarningログ

### リリース / 切り戻し

- リリース:
  - 開発環境で1日運用し、メニュー可読性を確認して本適用
- 切り戻し:
  - 旧固定メニュー構成へ戻せるようコミットを分割

## 合意事項の確認と追跡

### このSpecが固定する決定

- アプリ別親カテゴリ表示
- 通知行表示形式（緊急度ラベル + 要約）
- クリア操作（通知/アプリ/全体）

### 逸脱時のルール

- Spec更新が必要:
  - メニュー階層変更、緊急度段階変更、クリア責務変更
- PRで説明で足りる:
  - 文言調整、表示件数上限、要約文字数
- ADR追加が必要:
  - 永続化導入やデータモデル大幅変更

## 実装計画

- フェーズ1: データモデル拡張と受信時分析固定化
- フェーズ2: アプリ別メニュー再構築とクリック/クリアイベント実装
- フェーズ3: テスト追加と実機UX調整（色ラベル方式確定）
